:Stem: latexmath

= Uplink Beacon Laser

As of now the Beacon laser subsystem would follow a similar congifuration to one of Nasa's beacon lasers: https://ao.jpl.nasa.gov/Publications/published_troberts2016.pdf. 4 lasers will be used with a Master Oscillator Power Amplifier (MOPA) each with custom mounting (Deal with later).

The rest of this segment is based on the MATLAB script that captures scintillation by normalized irradance for an uplink laser. All formulas are based on the book "Laser Beam Scintillation with Applications" by Andrews, Phillips, and Hopen.

== Scintillation Index and Irradiance Fluctation Model

The simulation's main objective is to calculate and model the scintillation index latexmath:[\sigma_I^2]. This is the normalized varriance of the irradiance. (Add graph) The MATLAB script first determines a point scintillation index latexmath:[(\sigma_I^2)_p] for a single-transmitter path, which is considred the main basis for this simulation. The value latexmath:[(σ_{I,point}^2)] will be calculated using the Rytov variance and is generally considerd valid across weak to strong turbulence conditions. 

[latexmath]
++++
σ_{I,point}^2 = \exp \left( \frac{0.49 σ_2^2}{(1 + 0.56 σ_2^{12/5})^{7/6}} + \frac{0.51 σ_2^2}{(1 + 0.69 σ_2^{12/5})^{5/6}} \right) - 1
++++

This script models scintillation using Gamma_Gamma Distribution, which is the product of two indpendent Gamma-distributed random varibles that will be noted as latexmath:[x] and latexmath:[y] where

[latexmath]
++++
x \text{: Represents large-scale turbulence effects}
\newline
y \text{: Represents small-scale turbulence effects}
++++

Large scale turbulence can be reresented as slow and broad variations within temperatures and pressures of the environment. Those issues cause beam spread, slow fading events and flucuations of angle precision. Small scale turbulence can be represented as rapid fluctuations in the refractive index that leads to speckles which directly causes beam wander and scattering.  The final normalized irradiance latexmath:[I] is calculated as the product of these two variables. 

== Model and Rytov Variance

For an uplink beacon laser, a spherical wave model was considered based on its accurate representaiton of a laser beam transmitted from a small ground source to a Low Eath Orbit (LEO) sattelite. The beam starts at the ground and immediately has to face the densest part of Earth's atmosphere where turbulence is at its peak. As the laser traverses to the sattelite located in space (obviously), the atmospheric density decreases as well as the effects of turbulence. In this case the laser would experience strong divergence from the point source and propogate in all directions like a sphere. This logic could also be applied for justifying a plane-wave model for downlink simulations in which the order of turbulence is reversed. Then the laser beam would physically spread like a planar wave.

The Rytov variance latexmath:[(σ_2^2)] quantifies the strength of the atmposheric turbulence. For an uplink spherical wave, the Rytov variance was found using the Hufnagel-Valley (H-V) atmospheric model for the refractive-index structure prameter, latexmath:[C_n^2(h)], along with the entire pathlength: 

[latexmath]
++++
C_n^2(h) = 0.00594 \left( \frac{v_{wind}}{27} \right)^2 (10^{-5}h)^{10} \exp \left( -\frac{h}{1000} \right) + 2.7 \times 10^{-16} \exp \left( -\frac{h}{1500} \right) + A_{ground} \exp \left( -\frac{h}{100} \right)
++++

The Rytov variance itself is calcualted using the integral of this model while being weighted by the spherical 

[latexmath]
++++
σ_2^2 = 2.25 \cdot \mu_3 \cdot k^{7/6} (H - h_0)^{5/6} (\sec(\theta))^{11/6}
++++

where latexmath:[\mu_3] is the result of the integral:

[latexmath]
++++
\mu_3 = \int_{h_0}^{H} C_n^2(h) \left( \frac{h - h_0}{H - h_0} \right)^{5/6} \left( 1 - \frac{h-h_0}{H-h_0} \right)^{5/6} ,dh
++++

== Dealing with Transmitter Diversity

The script also mainly focuses on reducing scintillation through transmitter diversity. Basically multiple separated transmitters create uncorrelated paths independent of each other will reduce overall scintillation. This is modeled by: 

[latexmath]
++++
σ_{I,M}^2 = \frac{σ_{I,point}^2}{M}
++++

To apply averaging correctly with the Gamma-Gamma distribution, the MATLAB script adjusts latexmath:[\alpha \text{ and } \beta] paramters, that are inversely related to the large scale latexmath:[σ_x^2] and small scale latexmath:[σ_y^2] irradiance variances. 

[latexmath]
++++
α_{effective} = \frac{1}{σ_x^2 / M}
++++

[latexmath]
++++
β_{effective} = \frac{1}{σ_y^2 / M}
++++

The script that use the altered parameters to generate the Gamma-Gamma distrbution with less irradiance based on the number of transmitter counts.

== Simulated Scintillation

The simulated scintillaiton index is then given with the normalized variance or irradiance fluctaitons that were found in previous calculations.

[latexmath]
++++
σ_{I}^2 = \frac{\langle I^2 \rangle - \langle I \rangle^2}{\langle I \rangle^2}
++++

This is the MATLAB code, all the formulas are noted with page numbers based on their index in PDF page with Equations and chapters also noted.

[source,matlab]
----
clear; close all; clc;

% Main function to encapsulate the entire application logic
function createScintillationApp()

    %% System and Atmospheric Parameters
    wavelength = 1.064e-6;      % Wavelength [m] (lambda)
    H = 38000e3;                % Satellite altitude (Rounded GEO - Geostaionary Earth Orbit) [m]
    h0 = 2;                     % Ground station altitude [m]
    zenithAngle = 50;           % Zenith angle [degrees]
    % D = 0.5;                  % Receiver aperture diameter [m] (Used in downlink version, but not for uplink
    A_ground = 1.7e-14;         % Ground level turbulence strength [m^(-2/3)]
    v_wind = 21;                % RMS wind speed for H-V model [m/s]

    % Simulation Parameters
    numPoints = 2048;           % Number of samples for the simulation
    duration = 1;               % Simulation duration [s]
    Fs = numPoints/duration;    % Sampling frequency [Hz]
    t = (0:numPoints-1)/Fs;     % Time vector for plotting [s]

    %% Fade and Surge Analysis Parameters (Initial Values)
    enableFadeAnalysis = true;    % Set to true to show thresholds and calculate events
    fadeThreshold = 0.5;          % Irradiance level below which a fade is counted
    surgeThreshold = 2.0;         % Irradiance level above which a surge is counted

    %% Scintillation Calculation for Uplink Path (Constant parameters)
    % Optical wave number (Pg 23, Ch 1, second page (literally first eq but no tag))
    k = 2 * pi / wavelength;
    % L = (H - h0) / cosd(zenithAngle); % Total path length (General pathlength eq in Ch 2/ not used for now)

    % Rytov Variance for an Uplink Spherical Wave
    % The Rytov variance for an uplink spherical wave (sigma_2_sq) is approximately
    % equal to that of a downlink plane wave (sigma_1_sq). (Stated in Pg.291, (Textbook 268))
    % H-V Model: (Pg 281, Ch 8, Equation (43))
    Cn2_h = @(h) 0.00594*(v_wind/27)^2 * (1e-5*h).^10 .* exp(-h/1000) + ...
                 2.7e-16 * exp(-h/1500) + A_ground * exp(-h/100);

    % Integral for mu_3, used in the Rytov variance calculation (Spherical Version).
    % (Pg 283, Ch 8, Equation (49))
    integrand_mu3 = @(h) Cn2_h(h) .* ((h - h0)/(H - h0)).^(5/6) .* (1 - (h-h0)/(H-h0)).^(5/6);
    mu3 = integral(integrand_mu3, h0, H);

    % Final Rytov Variance calculation for the uplink spherical wave.
    % (Pg 291, Ch 8, Equation (72))
    sigma_2_sq = 2.25 * mu3 * k^(7/6) * (H - h0)^(5/6) * secd(zenithAngle)^(11/6);

    % Scintillation Index Model for an Uplink Spherical Wave
    % This model is valid for weak to strong irradiance fluctuations.
    % (Pg 293, Ch 8, Equation (85))
    sigma_I_sq_point = exp( ...
        (0.49 * sigma_2_sq) / (1 + 0.56 * sigma_2_sq^(12/5))^(7/6) + ...
        (0.51 * sigma_2_sq) / (1 + 0.69 * sigma_2_sq^(12/5))^(5/6) ...
    ) - 1;

    % Check Variables
    % Zenith Angle: 45-60 degrees, Check if fprintf works
    % Rytov Variance: Anything 0 to 2 [anymore is off]
    % Point Scintillation Index: 0 to 1 [0 is good, 1 is bad]
    fprintf('--- Uplink Model Setup ---\n');
    fprintf('Zenith Angle: %.1f deg\n', zenithAngle);
    fprintf('Rytov Variance (σ₂²): %.4f\n', sigma_2_sq);
    fprintf('Point Scintillation Index (σ_I²): %.4f\n\n', sigma_I_sq_point);

    %% Calculate Aperture Averaging for the Receiver Aperture
    % A_factor = 1.0; % Aperture averaging isn't used for uplink spherical wave (Used for plane waves/downlink)

    %% Initialize Plot Handles and Data Storage
    transmitterCounts = [1, 2, 4, 8];
    colors = lines(length(transmitterCounts));
    lineHandles = gobjects(length(transmitterCounts), 1); % Handles for intensity lines
    fadeThresholdLine = []; % Handle for fade threshold line
    surgeThresholdLine = []; % Handle for surge threshold line

    % Variables to store simulation results, updated by updatePlotAndAnalysis
    allIntensities = zeros(numPoints, length(transmitterCounts));
    calculatedScintIndices = zeros(length(transmitterCounts), 1);
    fadeCounts = zeros(length(transmitterCounts), 1);
    surgeCounts = zeros(length(transmitterCounts), 1);
    fadeProbabilities = zeros(length(transmitterCounts), 1);
    expectedFades = zeros(length(transmitterCounts), 1);

    %% Interactive Figure and UI Setup
    fig = figure('Name', 'Uplink Scintillation Model (Andrews, Phillips, & Hopen)', 'Position', [100 100 1100 600]);
    ax = axes('Parent', fig, 'Units', 'normalized', 'Position', [0.3 0.15 0.65 0.75]);
    hold(ax, 'on');

    % Initial plot of threshold lines
    fadeThresholdLine = plot(ax, t, ones(size(t))*fadeThreshold, 'r--', 'LineWidth', 1, 'DisplayName', 'Fade Threshold');
    surgeThresholdLine = plot(ax, t, ones(size(t))*surgeThreshold, 'k:', 'LineWidth', 1, 'DisplayName', 'Surge Threshold');

    % Main UI panel for controls, using normalized units
    uiPanelMain = uipanel('Title','Controls', 'FontSize', 12, ...
            'Units', 'normalized', 'Position',[0.02 0.1 0.25 0.8]);

    % Sub-panel for # of Transmitters
    uiPanelTransmitters = uipanel(uiPanelMain, 'Title','# of Transmitters', 'FontSize', 10, ...
            'Units', 'normalized', 'Position',[0.05 0.45 0.9 0.5]); 

    % Checkboxes for Transmitters
    for i = 1:length(transmitterCounts)
        uicontrol(uiPanelTransmitters, 'Style', 'checkbox', ...
                  'String', sprintf('%d Transmitter(s)', transmitterCounts(i)), ...
                  'Value', 1, ...
                  'Units', 'normalized', ...
                  'Position', [0.1 (1 - (i * 0.2)) 0.8 0.15], ... % Normalized position within sub-panel
                  'Callback', {@toggleLineVisibility, i}, ...
                  'UserData', i); % Store index 'i' for later retrieval of lineHandles(i)
    end

    % Sub-panel for Threshold Toggles and Inputs
    uiPanelThresholds = uipanel(uiPanelMain, 'Title','Threshold Settings', 'FontSize', 10, ...
            'Units', 'normalized', 'Position',[0.05 0.1 0.9 0.3]); % Position relative to uiPanelMain

    % Fade Threshold Input
    uicontrol(uiPanelThresholds, 'Style', 'text', 'String', 'Fade Threshold:', ...
              'Units', 'normalized', 'Position', [0.05 0.75 0.4 0.15], 'HorizontalAlignment', 'left');

    editfadeThreshold = uicontrol(uiPanelThresholds, 'Style', 'edit', ... % Warning shown, but this is needed to when values change in txtbox
              'String', num2str(fadeThreshold), ...
              'Units', 'normalized', 'Position', [0.5 0.75 0.45 0.15], ...
              'Callback', @(src, event) updateThresholds(src, event, 'fade'));

    % Surge Threshold Input
    uicontrol(uiPanelThresholds, 'Style', 'text', 'String', 'Surge Threshold:', ...
              'Units', 'normalized', 'Position', [0.05 0.5 0.4 0.15], 'HorizontalAlignment', 'left');

    editSurgeThreshold = uicontrol(uiPanelThresholds, 'Style', 'edit', ... % Warning shown, but this is needed to when values change in txtbox
              'String', num2str(surgeThreshold), ...
              'Units', 'normalized', 'Position', [0.5 0.5 0.45 0.15], ...
              'Callback', @(src, event) updateThresholds(src, event, 'surge'));

    % Checkboxes for Threshold Visibility 
    uicontrol(uiPanelThresholds, 'Style', 'checkbox', ...
              'String', 'Show Fade Line', ...
              'Value', 1, ...
              'Units', 'normalized', ...
              'Position', [0.1 0.25 0.8 0.15], ...
              'Callback', {@toggleThresholdVisibility, fadeThresholdLine});

    uicontrol(uiPanelThresholds, 'Style', 'checkbox', ...
              'String', 'Show Surge Line', ...
              'Value', 1, ...
              'Units', 'normalized', ...
              'Position', [0.1 0.05 0.8 0.15], ...
              'Callback', {@toggleThresholdVisibility, surgeThresholdLine});

    % call to run the simulation and update the plot and info
    updatePlotAndAnalysis();

    % Function to re-run simulation and update plot/analysis
    function updatePlotAndAnalysis()
        % Generate Data for Different Transmitter Counts
        % Gamma-Gamma distribution used to model irradiance fluctuations.
        % (Pg 110, Ch 2)
        for j = 1:length(transmitterCounts)
            numTransmitters = transmitterCounts(j);

            % Scintillation reduction due to transmitter diversity:
            % Assuming uncorrelated (or sufficiently separated) transmitter paths,
            % the scintillation index is reduced by the number of transmitters (M).
            % Aperture averaging is negligible (A_factor = 1).
            sigma_I_sq_M = sigma_I_sq_point / numTransmitters; % Overall scintillation
            calculatedScintIndices(j) = sigma_I_sq_M;

            % Gamma-Gamma PDF parameters alpha and beta for the uplink spherical wave model.
            % From the large-scale (x) and small-scale (y) log-irradiance variances.
            % Large-scale log-irradiance variance for uplink spherical wave.
            % (Pg 293, Ch 8, Equation (84))
            sigma_lnx_sq = (0.49 * sigma_2_sq) / (1 + 0.56 * sigma_2_sq^(12/5))^(7/6);

            % Small-scale log-irradiance variance for uplink spherical wave.
            % (Pg 293, Ch 8, Equation (78))
            sigma_lny_sq = (0.51 * sigma_2_sq) / (1 + 0.69 * sigma_2_sq^(12/5))^(5/6);
            
            % Convert log-irradiance variances to irradiance variances.
            % (Pg 267, Ch 8, Equation (4))
            sigma_x_sq = exp(sigma_lnx_sq) - 1;
            sigma_y_sq = exp(sigma_lny_sq) - 1;

            % Inverse relationship for alpha and beta.
            alpha_effective = 1 / (sigma_x_sq / numTransmitters); % Scaling factor based on # of Transmitters
            beta_effective = 1 / (sigma_y_sq / numTransmitters);

            % Generate random variables from two gamma distributions. Their product
            % follows a Gamma-Gamma distribution, modeling the irradiance.
            % (Page 111, Chapter 2, Based off of eq 40 and 41 but used prefined gamma distribution function)
            large_scale_irradiance = gamrnd(alpha_effective, 1/alpha_effective, numPoints, 1);
            small_scale_irradiance = gamrnd(beta_effective, 1/beta_effective, numPoints, 1);

            % Final intensity is the product of the two modulated processes
            % Pg 110, ch2, I = xy where x is large and y is small scale atmospheric effects
            intensity = large_scale_irradiance .* small_scale_irradiance;
            allIntensities(:,j) = intensity;

            % Calculate fade and surge events
            if enableFadeAnalysis
                isFaded = intensity < fadeThreshold;
                fadeCrossings = diff(isFaded) == 1;
                fadeCounts(j) = sum(fadeCrossings);
                fadeProbabilities(j) = sum(isFaded) / numPoints; % Probability of fade (Pg 247, Eq 17 is theoretical basis, ts is good for now)

                isSurged = intensity > surgeThreshold;
                surgeCrossings = diff(isSurged) == 1;
                surgeCounts(j) = sum(surgeCrossings);

                % Calculate Expected Number of Fades (Simplified Rice's formula approximation)
                % (Pg 273, Chapter 8, sentence with LEO and GEO)
                L_corr_eff = 100; % meters, a rough estimate for uplink correlation width I should probably find a concrete value for this though
                f_char = v_wind / L_corr_eff; 
                expectedFades(j) = f_char * fadeProbabilities(j) * duration; % Number of fades in 'duration' seconds
            end
        end

        % Update plot lines
        set(fadeThresholdLine, 'YData', ones(size(t))*fadeThreshold);
        set(surgeThresholdLine, 'YData', ones(size(t))*surgeThreshold);

        % Update intensity lines: Create if not exists, otherwise update YData
        hold(ax, 'on'); % Ensure hold is on before plotting/updating
        for j = 1:length(transmitterCounts)
            % Check if the line handle is valid (i.e., it's a graphics object and not deleted)
            if isgraphics(lineHandles(j))
                set(lineHandles(j), 'YData', allIntensities(:,j));
            else
                % Line doesn't exist or was deleted, create it
                lineHandles(j) = plot(ax, t, allIntensities(:,j), ...
                    'Color', colors(j,:), ...
                    'LineWidth', 1.5, ...
                    'DisplayName', sprintf('%d Transmitter(s)', transmitterCounts(j)), ...
                    'Visible', 'on');
            end
        end
        hold(ax, 'off'); % Ensure hold is off after updating all lines

        title(ax, 'Simulated Uplink Scintillation with Transmitter Diversity');
        xlabel(ax, 'Time (s)');
        ylabel(ax, 'Normalized Irradiance');
        grid(ax, 'on');
        ylim(ax, [0 max(3.5, ceil(max(allIntensities(:))))]); % Re-adjust y-limit
        legend(ax, 'show', 'Location', 'northeast');

        % Display results in command window
        fprintf('- Scintillation Index Comparison -\n');
        fprintf('Based on satellite uplink (spherical wave).\n');
        fprintf('-------------------------------------------------------\n');
        for j = 1:length(transmitterCounts)
            % Scintillation index is the normalized variance of irradiance
            % (Pg 88, Ch 2, Equation (1))
            simulated_scintIndex = var(allIntensities(:,j)) / mean(allIntensities(:,j))^2;
            fprintf('%d Transmitter(s): Theoretical σ_I² = %.4f | Simulated σ_I² = %.4f\n', ...
                    transmitterCounts(j), calculatedScintIndices(j), simulated_scintIndex);
        end
        if enableFadeAnalysis
            fprintf('\n--- Fade and Surge Event Analysis ---\n');
            fprintf('Fade Threshold: %.2f | Surge (Oversaturation) Threshold: %.2f\n', fadeThreshold, surgeThreshold);
            fprintf('--------------------------------------------------------------------------\n');
            fprintf('%-16s | %-15s | %-15s | %-15s | %-15s\n', 'Transmitter(s)', 'Fade Prob.', 'Fade Events', 'Surge Events', 'Expected Fades');
            fprintf('-------------------------------------------------------------------------\n');
            for j = 1:length(transmitterCounts)
                fprintf('%-16d | %-15.4f | %-15d | %-15d | %-15.2f\n', ...
                    transmitterCounts(j), fadeProbabilities(j), fadeCounts(j), surgeCounts(j), expectedFades(j));
            end
        end
    end

    % Callback function for transmitter checkboxes
    function toggleLineVisibility(src, ~, lineIndex)
        % Retrieve the actual line handle from the lineHandles array using the stored index
        lineHandle = lineHandles(lineIndex);
        if get(src, 'Value')
            set(lineHandle, 'Visible', 'on');
        else
            set(lineHandle, 'Visible', 'off');
        end
    end

    % Callback function for threshold visibility checkboxes
    function toggleThresholdVisibility(src, ~, lineHandle)
        if get(src, 'Value')
            set(lineHandle, 'Visible', 'on');
        else
            set(lineHandle, 'Visible', 'off');
        end
    end

    % Callback function for threshold input fields
    function updateThresholds(src, ~, type)
        newValue = str2double(get(src, 'String'));
        if isnan(newValue) || newValue < 0
            % Invalid input, revert to previous value and warn
            if strcmp(type, 'fade')
                set(src, 'String', num2str(fadeThreshold));
            else
                set(src, 'String', num2str(surgeThreshold));
            end
            warning('Invalid input. Please enter a non-negative numeric value or else.');
            return;
        end

        if strcmp(type, 'fade')
            fadeThreshold = newValue;
        else
            surgeThreshold = newValue;
        end
        updatePlotAndAnalysis(); % Re-run simulation and update plot/analysis
    end

end % End of createScintillationApp function

% Call the main function to run the application
createScintillationApp();
